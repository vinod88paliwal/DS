package com.ds.problems;

							Objects Memory Allocation :
							---------------------------
https://www.javamex.com/tutorials/memory/object_memory_usage.shtml
https://dzone.com/articles/java-how-to-calculate-size-of-objects-amp-arrays-b

# There are 8 primitive types :-->

Primitive Types     Size in Bytes
---------------	   ---------------	
byte & boolean   -->    1 
char & short     -->    2
int & flot		 -->	4 
long & double	 -->	8

1 Byte  -->  8 bit

Object overhead for "housekeeping" information :
----------------------------------------------
Instances of an object on the Java heap don't just take up memory for their actual fields. Inevitably, they also require some "housekeeping" information, 
such as recording an object's class, ID and status flags such as whether the object is currently reachable, currently synchronization-locked etc. 
In Hotspot:
    a normal object requires 8 bytes of "housekeeping" space;
    arrays require 12 bytes (the same as a normal object, plus 4 bytes for the array length). 

Object size granularity :
------------------------
In Hotspot, every object occupies a number of bytes that is a multiple of 8. If the number of bytes required by an object for its header and fields is not a multiple 8, then you round up to the next multiple of 8.

This means, for example, that:

    a bare Object takes up 8 bytes;
    an instance of a class with a single boolean field takes up 16 bytes: 8 bytes of header, 1 byte for the boolean and 7 bytes of "padding" to make the size up to a multiple of 8;
    an instance with eight boolean fields will also take up 16 bytes: 8 for the header, 8 for the booleans; since this is already a multiple of 8, no padding is needed;
    an object with a two long fields, three int fields and a boolean will take up:
        8 bytes for the header;
        16 bytes for the 2 longs (8 each);
        12 bytes for the 3 ints (4 each);
        1 byte for the boolean;
        a further 3 bytes of padding, to round the total up from 37 to 40, a multiple of 8. 
        
Example : 
---------
a Java object which holds two int variables, one boolean variable, one Long object, and a reference to other objects. The memory would turn out to be following:

    8 bytes for the object header
    2 x 4 = 8 bytes for two int variables
    1 byte for a boolean variable
    8 bytes (object reference) + 8 bytes for long data type = 16 bytes for long object
    4 bytes for reference to some other object
    The total size of the above mentioned object will be 8 + 8 + 1 + 16 + 4 = 37 bytes + 3 bytes (for padding) = 40 bytes.
        

Memory usage of a single-dimension array :
-----------------------------------------
A single-dimension array is a single object. As expected, the array has the usual object header. However, this object head is 12 bytes to accommodate a four-byte array length. 
Then comes the actual array data which, as you might expect, consists of the number of elements multiplied by the number of bytes required for one element, depending on its type. The memory usage for one element is 4 bytes for an object reference;
If the total memory usage of the array is not a multiple of 8 bytes, then the size is rounded up to the next mutlitple of 8 (just as for any other object). 


Memory usage of a two-dimensional array:
----------------------------------------


Memory usage of Java Strings :
-----------------------------
We know that every object has at least 8 bytes of housekeeping data, and arrays 12 bytes, and will be padded to a multiple of 8 bytes;
Java String actually consists of more than one object; 

Minimum memory usage of a Java String (in the Hotspot Java 6 VM) is generally as follows:
Minimum String memory usage (bytes) = 8 * (int) ((((no chars) * 2) + 45) / 8)  

Or, put another way:

    multiply the number of characters of the String by two;
    add 38;
    if the result is not a multiple of 8, round up to the next multiple of 8;
    the result is generally the minimum number of bytes taken up on the heap by the String. 

In general, the formula above will give the memory usage for a "newly created" string. However, there are some subtle cases where:

Understanding String memory usage :  To understand the above calculation, we need to start by looking at the fields on a String object. A String contains the following: 
--------------------------------

* a char array— thus a separate object— containing the actual characters;
* an integer offset into the array at which the string starts;
* the length of the string;
* another int for the cached calculation of the hash code

This means even if the string contains no characters, it will require 4 bytes for the char array reference, plus 3*4=12 bytes for the three int fields, plus 8 bytes of object header. This gives 24 bytes (which is a multiple of 8 so no "padding" bytes are needed so far). Then, the (empty) char array will require a further 12 bytes (arrays have an extra 4 bytes to store their length), plus in this case 4 bytes of padding to bring the memory used by the char array object up to a multiple of 16. So in total, an empty string uses 40 bytes.
Example:
--------
If the string contains, say, 17 characters, then the String object itself still requires 24 bytes. But now the char array requires 12 bytes of header plus 17*2=34 bytes for the seventeen chars. Since 12+34=46 isn't a multiple of 8, we also need to round up to the next multiple of 8 (48). So overall, our 17-character String will use up 48+24 = 72 bytes. As you can see, that's quite a long way off the 18 bytes that you might have expected if you were used to C programming in the "good old days"1. 

----------------------------------
Quest : why its possible to assign long value to a float vriable ?
Ans :  Yea,its a good question.because anyone can doubt that if long size is 8 byte while float size is only 4 byte then how can we assign long value to float variable,sorry for repeating the question.
But once you see the range of float you will see that it is more than range of long,now you should ask how float range is higher than long.
then your answer is since bit manipulation is different in case of float than as in int.

Quest : Why string is not a 9th Data-Type ? 
Ans : String is an Object, meaning it's a reference type, not a primitive type. By Object, String is it's own class. We can tell this because it starts with an Uppercase in it's name. This means there is a java class called "String", in the java.lang package. To instantiate a String object, you can do { String test = "my string"; } or you can do { String test = new String("my string"); } to instantiate a String object. So when someone asks you, is String a primitive type, you say no, it is its own class, and when it's referenced, it's a reference type of String, and therefor it's an object, not a primitive data type.

Quest : 


------------------------------



--------------------------------------------------------------------------------

# What is encapsulation & Abstraction ?
==> 
Encapsulation:-->
-----------------
Encapsulation is a process to bind the data member and member function in single unit (i.e. : Class).
Encapsulation is to hide the implementation details from users. If a data member is private it means it can only be accessed within the same class. No outside class can access private data member (variable) of other class. However if we setup public getter and setter methods to update (for e.g. void setSSN(int ssn))and read (for e.g.  int getSSN()) the private data fields then the outside class can access those private data fields via public methods. 
This way data can only be accessed by public methods thus making the private fields and their implementation hidden for outside classes. That’s why encapsulation is known as data hiding. 

public class EncapsulationDemo{
    private int ssn;
    private String empName;
    private int empAge;

    //Getter and Setter methods
	}
	
Advantages of encapsulation:
  1. It improves maintainability and flexibility and re-usability: for e.g. In the above code the implementation code of void setEmpName(String name) and String getEmpName() can be changed at any point of time.
	 Since the implementation is purely hidden for outside classes they would still be accessing the private field empName using the same methods (setEmpName(String name) and getEmpName()). Hence the code can be maintained at any point of time without breaking the classes that uses the code. This improves the re-usability of the underlying class.
2. The fields can be made read-only (If we don’t define setter methods in the class) or write-only (If we don’t define the getter methods in the class). For e.g. If we have a field(or variable) which doesn’t need to change at any cost then we simply define the variable as private and instead of set and get both we just need to define the get method for that variable. Since the set method is not present there is no way an outside class can modify the value of that field.
	
3. It makes the code loosely coupled.	
	
Abstraction :-->
------------------
Abstraction is process of showing only the functionality and enforcing the implementation needs to be done based on child class requirement. 
So when do you use abstraction ? ( most important in my view ) in other words....
when you know something (some functionality) needs to be there but not sure how exactly it should look lik ( or how should be implemented)e. e.g. when I am creating a class called Vehicle, I know there should be methods like start() and stop() but don't know how that start and stop method should work, because every vehicle can have different start and stop mechanism e.g. some can be started by kicking or some can be by pressing buttons . Same concept apply to interface in Java as well,

So implementation of those start() and stop() methods should be left to there concrete implementation e.g. Scooter , MotorBike , Car etc.

Read more: http://javarevisited.blogspot.com/2010/10/abstraction-in-java.html#ixzz3YEEizm4y

# This adds strength to the OOAD principle -"Code should be open for Extension but closed for Modification".
# Abstraction refers to the ability to make a class abstract in OOP.


Polymorphism :-->  When one task is performed in different ways i.e. known as polymorphism. In java, we use method overloading and method overriding to achieve ----------------   polymorphism.
				   Polymorphism in java is a concept by which we can perform a single action by different ways.
				
Inheritance :--> Its a process of aquiring the properties of Super class into sub class.
---------------


Quest : How to write an immutable Class?  Full Details :
http://www.journaldev.com/129/how-to-write-an-immutable-class

Immutable objects are instances whose state doesn’t change after it has been initialized. For example, String is an immutable class and once instantiated its value never changes.

Immutable objects are good for caching purpose because you don’t need to worry about the value changes. Other benefit of immutable class is that it is inherently thread-safe, so you don’t need to worry about thread safety in case of multi-threaded environment.

Ans: To create a class immutable, you need to follow following steps:

1.  Declare the class as final so it can’t be extended.
2.  Make all fields private so that direct access is not allowed.
3.  Don’t provide setter methods for variables.
4.  Make all mutable fields final so that it’s value can not be changed once assigned .
5.  Initialize all the fields via a constructor performing deep copy.
6.  Perform cloning of objects in the getter methods to return a copy rather than returning the actual object reference.

Example : package com.vinod.mutable.ImmutablelClassExample;

Output of the above program is:
Performing Deep Copy for Object initialization
true
false
ce id:10
ce name:original
ce testMap:{2=second, 1=first}
ce id after local variable change:10
ce name after local variable change:original
ce testMap after local variable change:{2=second, 1=first}
ce testMap after changing variable from accessor methods:{2=second, 1=first}

Now lets comment the constructor providing deep copy and uncomment the constructor providing shallow copy. Also uncomment the return statement in getTestMap() method that returns the actual object reference and then execute the program once again.
	
Performing Shallow Copy for Object initialization

true
true
ce id:10
ce name:original
ce testMap:{2=second, 1=first}
ce id after local variable change:10
ce name after local variable change:original
ce testMap after local variable change:{3=third, 2=second, 1=first}
ce testMap after changing variable from accessor methods:{3=third, 2=second, 1=first, 4=new}

As you can see from the output, HashMap values got changed because of shallow copy in the constructor and providing direct reference to the original object in the getter function.


6 Benefits of Programming with Immutable Objects in Java :
-----------------------------------------------------------
1. Immutable objects are thread-safe so you will not have any synchronization issues.
2. Immutable objects are good for Map keys and Set elements, since these typically do not change once created.
3. Immutability makes it easier to write, use and reason about the code (class invariant is established once and then unchanged)
4. Immutability makes it easier to parallelize your program as there are no conflicts among objects.
5. The internal state of your program will be consistent even if you have exceptions.
6. References to immutable objects can be cached as they are not going to change.


----------------------------

Quest : What are Java nested classes ? http://www.journaldev.com/996/java-nested-classes-java-inner-class-static-nested-class-local-inner-class-and-anonymous-inner-class
Ans : Java nested classes are defined as class inside the body of another class. A nested class can be declared private, public, protected, or with default access whereas an outer class can have only public or default access.

Benefits of Java Nested Class
1. If a class is useful to only one class, it makes sense to keep it nested and together. It helps in packaging of the classes.
2. Nested classes increases encapsulation. Note that inner classes can access outer class private members as well and at the same time we can hide inner class from outer world.
3. Nesting small classes within top-level class, places the code closer to where it is used and makes code more readable and maintainable.

---------------------------------------

Quest 1.  Why getter and setter are better than public fields in Java ? or Why Setter/getter are required instead public field?

Ans : Main problem with making field public instead of getter and setter is that it violates Encapsulation by exposing internals of a class. Once you exposed internals of class you can not change internal representation or make it better until making change in all client code. Since every code change comes with risk and cost of regression testing is high during maintenance, its not a good idea to make field public in Java.  

1) getter and setter method gives you centralized control on how a particular field is initialized and should be provided to client which makes validation and debugging much easier. you can simply put a breakpoints or print statement to see which thread are accessing and what values are going out.

On validation front, you can easily avoid an incorrect value for a particular field, i.e. if field is note-null than you can throw NullPointerException or IllegalArgumentException. with public field your client code will break when it start using that field without knowing which part of your code is setting incorrect or null value.

Accessors and mutators should be used with all variables that should be exposed to other classes to maintain loose coupling.
http://www.ayomaonline.com/academic/coupling-loosely-coupling-and-tightly-coupling/

2) By making fields private and providing getter and setter and following java bean naming convention you make your class usable with many open source library and framework e.g. display tag. which uses combination of reflection and Java bean naming convention to dynamically load and access fields.

3) with getter and setter you give an opportunity to Subclass to override these method and return what makes more sense in context of sub class.

4) To perform Deep copy initialization and to return copy of object.

5) To increase Loose Coupling.

-------------------------------------

Coupling & Cohesion :-->
Program should be Loose Coupling and High Cohesion.
http://javabambino.blogspot.in/2013/06/loose-coupling-and-high-cohesion-in-java.html

Coupling:--> Coupling is a measurement of interdependencies between different modules in an application. In simpler terms, how much a class is dependent on entities of another class.
Lets say we have a class A and another class B. class A has methods that depend upon class B entities directly, so whenever there is a change in class B, there will be a risk of functionality breaking in class A. This is tight coupling where there is heavy dependency. Loose coupling means the opposite. 
Lets take a small example:
	
class MyReader {
 FilePath path;
 MyReader() {
    path = new FilePath();  //tight coupling
 }
}

So some change to FilePath will probably hit MyReader class and force a change here too.

Lets say FilePath class's instantiation logic changes and the author decides to add some parameters to its constructor by removing the no-arg one or opts for factory methods thereby privatizing the no-arg constructor.

class MyReader {
 FilePath path;
 MyReader(FilePath obj) {
  //loose coupling, MyReader is loosely coupled with FilePath class.
  path = obj;
 }
}

Now FilePath instance will be provided to MyReader from outside, instead of it looking out. This is an example of Dependency Injection in Spring framework, where the framework will provide the instance from specific bean.xml files. In simpler terms, tight coupling is bad and risky. Note that loose coupling reduces the change risks, refactoring and thereby maintenance.

Best Practices for loose coupling:-->
* Don’t access local data of the other modules (classes, packages).
* Related to the above – you should only depend on the public interface of a class and not it’s inner workings.
* Pass your configuration, data and dependencies through either constructors or method parameters (sometimes called Dependency Injection).

Read more: http://www.javaexperience.com/what-is-coupling-and-cohesion-in-oops/#ixzz3Z5IkczFc

Cohesion--> Cohesion is something that defines how close and complete a class (module) is in its functionality. 
===========
This might represent higher cohesion:-->
class MyReader{
 public MyData readFromDisk(Parameter fileName){...};
 public MyData readFromWeb(Parameter url){...};
 public MyData readFromNetwork(Parameter networkLoc){...};
}

Look how well-focused the class is in its purpose. The class is named "MyReader" and its intended purpose is to read the resource, and it does only so. It does not implement other things. Its highly cohesive. 

Lets look at low cohesion example. 
class MyReader{
 //validate the resource path
 public boolean validateLocation(String path){
  return ping(pathIP) && checkFTP(path);
 }
 private static boolean ping(String path){...};
 private static boolean checkFTP(String path){...};
 
 //read the resource
 public MyData readFromDisk(String fileName){...};
 public MyData readFromWeb(String url){...};
 public MyData readFromNetwork(String networkAddress){...};
}
Well, the read operations are well defined, but it also implements logic to validate path which creates low cohesion.

Benefits of higher cohesion:

* The objective of the class is easily understandable and enhances the readability.
* The re-usability factor is highly increased, since a highly cohesive class is considered to be almost complete in its objective.
* Further code changes or enhancement becomes very easy because it has one type of functionality.

Best Practices for high cohesion:-->
* All the operations in a module (class, package) have much in common.
* Divide the modules so that each module is responsible for one thing only (also known as the Do One Thing Well principle). * * Avoid doing too much in one module.
* Elements in a module should be grouped together so that they perform some one well defined functionality.

-----------------------------------------------

Quest : What problems will you have if you don't override the hashCode() method?
Ans   : If we override only equals() and not hashCode(), the class uses its parent implementation. The default implementation which is provided in Object class (root) is to return memory location address of the object. 
So, if two objects are having same data, equals() will return true but hashCode() will return different values (two different address locations. If you are not using this class as key in HashMap or in HashSet, you won't see any issues with your code.

Example : Emp class with id and its constructor. Have overridden only equals() but not hashCode().
Emp e1 = new Emp(1);
Emp e2 = new Emp(1);	

System.out.println(e1.equals(e2)+" "+ (e1.hashCode() == e2.hashCode()));
Output : true false

When you try to put these two keys in a HashMap, what you expect is to have only one key stored (as they are same) but end up having both keys in the map. It is because the two keys will be stored in two different buckets in the map (hash bucket is decided based on hashcode which is different here.
The ideal way is to overrode hashCode() along with equals() method as you may be required to use it as key in HashMap in future.

Quest : What problems will you have if you don't override the equals() method?
Ans   : Then the default equals() method which your object inherits from class Object will be called and it performs a reference comparison.
        This means that no instance of your objects will ever be equal to any other instance, because every individual instance has a different reference.

Object Class equals():-->
 public boolean equals(Object obj) {
        return (this == obj);
    }

Note : We must override equals() and hashCode() methods in our user defined class if their object is used in HashMap or HashSet as key.

----------------------------------
Quest : What do you mean by Reenterent ? Is Syncronization Reenterent ?
Ans   : Synchronized methods/blocks in Java are reentrant. This means, that if a Java thread enters a synchronized block of code, and thereby take the lock on the monitor object the block is synchronized on, the thread can enter other Java code blocks synchronized on the same monitor object.  

Example : 
public class Foo {

 public synchronized void doSomething() {
        doAnotherSomething();
}
 public synchronized void doAnotherSomething(){}
 }
 
Once lock has been acquired on Foo object then on same object it can traverse in doSomething() and in doAnotherSomething() as, no need to take lock on Foo again. like in above case .

------------------------------------------------------------------

Quest :  Create two methods addEven and addOdd, first print 2, 4,6.... and secind 1,3,5 and call them in such a way that it prints 1,2,3,4....
Ans :com.vinod.qna.EvenOddWithSemaphore or com.vinod.analytical.EvenOddWithoutModulus or com.kp.EvenOddByFlagWithMethodsSemaphore or com.kp.EvenOddByFlagWithMethods


Quest : Deep and Shallow copy.
Ans : Done 

Quest: Hibernate Configuration, mapping and Spring-Hibernate Configuration.
Ans : Done.


Quest: Enum and its use in singleton.?
Ans: below link is very important.
http://java.dzone.com/articles/singleton-design-pattern-%E2%80%93

Quest: Semaphore ?
Ans : done

Quest: Cyclicbarrier and countdownLatch ?
Ans : Done

Quest: Which java version is released in market and you are using ?
Ans : Using : java1.8 & Released : Java 11

Quest : WAP to store an array in DB using hibernate ?
Ans: Done

Quest: How to change the heap size in environment ?
Ans : 

Quest: What should be an ideal size of heap for an application ?
Ans: 

Quest: Where you will configure DB details in server ?
Ans: Whepsphere =    & Jboss = runtime.properties (for application) & runtime.bat/runtime.sh (for jboss)

Quest: What is Outer and Inner Join ?
Ans : Done [Ref : DatabaseGranth]


Association : The relationship between two objects is known as the association.
-----------  Types : Composition, Aggregation and Inheritance.

Composition vs Aggregation vs Inheritance :
-------------------------------------------

Simple rules:
    A "owns" B = Composition : B has no meaning or purpose in the system without A
    A "uses" B = Aggregation : B exists independently (conceptually) from A
	A "is a" B = Inheritance : B inherits some or all properties from A.

Example : 
Composition :  A Car and it's part--> engines, wheels etc. Individual parts of the car can not function when a car is destroyed.
Aggregation : Student in School -->   when School closed, Student still exist and then can join another School or so.

Composition : Since Engine is-part-of Car, the relationship between them is Composition. Here is how they are implemented between Java classes.

public class Car {

    //final will make sure that it is initialized
    private final Engine engine;  
    private final Wheels wheels; 
    private final Seat seat; 
       
    public Car(){
       engine  = new Engine();
       wheels  = new Wheels();
       seat	  =  new Seat();
    }
}

class Engine {
    private String type;
}

class Wheels {
    private String type;
}

class Seat {
    private String type;
}


Aggregation : Since Organization has Person as employees, the relationship between them is Aggregation. Here is how they look like in terms of Java classes

public class Organization {
    private List employees;
}

public class Person {
    private String name;   
}



http://javarevisited.blogspot.in/2014/02/ifference-between-association-vs-composition-vs-aggregation.html

Quest: Encapsulation vs Abstractions ?
Ans : Abstractions : Give example of Set or Map, as it grose increases the size.

Quest: what is ThreadLocal, CountDownLatch, CyclicBarrier?
Ans: Done

Quest: Dirty read, phantom read and non repeatable reads in case of Databases and Hibernate?
Ans:

Quest: Spring bean scopes?
Ans: Singleton ,Prototype , Request, Application, Global-Application [last 3 applicable on Web Application].

Quest: Suggest test cases for a method which has nested if else inside?
Ans: 

Quest: ConcurrentHashmap: 3 threads reading and 1 writing. the writing thread calls map.clear(). What exception or effect will be caused by this?
Ans: com.vinod.concurrency.datastructures.ConcurrentHashMapWith4Threads

Quest: BlockingQueue based producer consumer problem.?
Ans: Done

Quest: How many design patterns you have implemented?
Ans : Singleton, Factory , Facade, Template

Quest: From a given string find out all permutations and combination and find out if any palindrome there once you find exit it in its first occurrence.?
Ans:

Quest: Read a two dimentional array which is unsorted and sort them and print.?
Ans:com.vinod.arraysort.Array2DSort

Quest: Given some set of String/character find out the count of repeared String/word.?
Ans:

Quest: If you have an array, how to delete the all odd/even index elements of the array ?
ANs: com.vinod.array.ArrayEvenOddDelete

Quest: If you have a matrix which have the element form 1, 2, 3...9 then print the matrix from 9,8,7....2,1 , how you can do it ?
Ans:

What is encapsulation & Abstraction ?
1. Big-O Notation ?
2. Reverse linked-list using recorsen ? and middle element of linked-list ?
3. Encapsulation & Abstraction ?
4. 2 for loops then complexcity of code ?
5. complexity of binary sort ?


Quest : When to prefer an Abstract class & Interface?
Ans   : 1. Abstract class and interface are used to create base class that can provide common function to its subclasses.
		If we have plan on updating this base class throughout the life of your program, it is best to allow that base class to be an abstract class. Why? Because you can make a change to it and all of the inheriting classes will now have this new functionality. If the base class will be changing often and an interface is used instead of an abstract class, we are going to run into problems.Once an interface is changed, any class that implements that will be broken.
		
	2. Interfaces means we are just defining a list of functions and subclasses have to provide specific implementation but abstract classes has the option of
		providing default functionality (concrete methods) and that can be used by subclasses along with defining subclasses specific method.
	
	3. If subclass is dependent on other class as well to override them methods then base class should be interface as java doesn’t supports multiple inheritance so subclass can extend one class along with base interface.
		

Quest : Can we overload methods that differ only by static keyword?
Ans   : No, Example --> com.oops.supersub.overload.OverloadMethod

Quest : Can we Override static methods in java?
Ans   : No , Example --> com.oops.supersub.A and *.B

Quest : Can there be a private constructor in an abstract class?
Ans	  : Yes, We can have private constructor ,variable and concrete methods but not private abstract method.
		Example --> com.oops.supersub.override.AbstractClass

Quest : Can we have a static & final method?
Ans   : Yes we can have . Example :--> com.oops.finaltest

Quest : Can we have an abstract & final method?  
Ans	  : No

Quest : Can a constructor be final?
Ans:    NO,Final keyword is used to protect the method to be overridden as we know constructor are not inherited hence there is no meaning of making 
        constructor final.


Quest : How to sort keys in a hashmap?
Ans	  :There are three ways of sorting keys in a Hashmap:
		1. By putting in the tree map and the printing the object.
		2. By using Collection.sort() method .
		3. By putting the keys in an array then sorting the array and then retrieving the data from the Hashmap using keys .

Quest : How to sort values in a hashmap?
Ans	  : 	


Quest : Why we should use Spring ?
Ans : Benefits of using Spring Framework
1.  Works on POJOs. Hence easier for dependency injection / injection of test data.
2.  With the Dependency Injection(DI) approach, dependencies are explicit and evident in constructor or JavaBean properties
3.  Provides loose coupling between different modules.
4.  Enhances modularity. Provides more readable codes.
5.  Effective in organizing the middle-tier applications.
6.  Flexible use of Dependency injection. Can be configured by XML based schema or annotation-based style.
7.  Supports declarative transaction, caching, validation and formatting.
8.  Bean configuration supports inheritance.
9.  Objects are created Lazily , Singleton - configuration.
10. Declarative transaction, security and logging service - AOP
11. Application code is much easier to unit test 
12. Spring Framework provides excellent integration with JDBC API and provides JdbcTemplate utility class that we can use to avoid bolier-plate code from our database operations logic such as Opening/Closing Connection, ResultSet, PreparedStatement etc.


Quest : Difference b/w IOC and Dependency injection ?
Ans	  : IoC --> Inversion of Control (IoC) means that objects do not construct other objects on which they rely on. Instead, the application will get these objects from an external framework (an IoC container). 
                One method which provides these objects to the application is called Dependency Injection (DI).  
Dependency injection: --> Dependency injection is a pattern used to create instances of classes that other classes rely on
						  without knowing at compile time which implementation will be used to provide that functionality.

						  
Quest : Why do we need Java web frameworks like Struts 2?
http://www.programcreek.com/2011/08/why-do-we-need-java-web-frameworks-like-struts-2/

Ans : This is very simple, real usage won't be easy like this. A real servlet has more work to do as summarized below: 
1. Binding request parameters to Java types. 
   String name = request.getParameter("name");
2. Validating data.
	E.g. There should not be numbers in people's name.
3. Making calls to business logic.
	E.g. Process the name for some purposes.
4. Communicate with the data layer.
	E.g. Store user data.
5. Rendering presentation layer (HTML, and so on).
	E.g. Return results for client browser. 

Of course, we can do all of those by ourselves, which is totally possible. However, that would take a lot of time. And very often, those functions are common features which can be implemented in some certain approach. 
Struts 2 is such an approach. It provides a standard way to implement those common functions following MVC design patterns. 

HCL :
----
Quest : What is the criteria and what is the use of it in Hibernate ?
Quest : Difference b/w ArrayList and Vector ?
Quest : What is Hash Code ?
Quest : When to use LinkedList then ArrayList?

Quest : What is Serialization means ?
Ans	  :  Example : com.qna.serialization.Employee ,SerializationUtil, SerializationTest
			
Serializable in Java : Serializable is the process, with that a Object can be wriiten into a file, (it can be read from the file called deserialization) or can be sent it over the network. 
-------------------- 
If you want a class object to be serializable, all we need to do it implement the java.io.Serializable interface. Serializable in java is a marker interface and has no fields or methods to implement. 
Serialization in java is implemented by ObjectOutputStream and ObjectInputStream, so we need to wrap over them to either save it to file or send it over the network.
If you want an object property to be not serialized to stream, you can use transient keyword like I have done with salary variable.

Outout ==> emp Object::Employee{name=Pankaj,id=100,salary=5000}
empNew Object::Employee{name=Pankaj,id=100,salary=0}

Since salary is a transient variable, it’s value was not saved to file and hence not retrieved in the new object. Similarly static variable values are also not serialized since they belongs to class and not object.


Quest : How to merge two shorted Array ?
Ans   : Create a new Array whose size would be equal to the size of both Arrays then Loop the new Array and check the Size of first Array if not NULL then take
        first element and copy to New Array once done then follow same with second Array.Note : Both Array we need to traverse inside new Array.
 
Quest : How HashSet internally works ?
Ans   : Internally uses HasMap [Ref : JavaGranthNew]

Quest : What is the benefit of IoC ?

Quest : what does @Service, @Controller, and @Repository annotation do ? What will happen if we do not use or remove from existing code?
Ans   : They are nothing but the specialized form of @Component annotation for certain situations. Instead of using @Component on a controller class in Spring MVC, we use @Controller , which is more readable and appropriate.
        @Component ::==> From Spring 2.5 annotation-based dependency injection was introduced, which automatically scans and register classes as Spring bean which is annotated using @Component annotation.
                    	 This means you don’t to declare that bean using the <bean> tag and inject the dependency, it will be done automatically by Spring. This functionality was enabled and disabled using <context:component-scan> tag in Spring Configuration file.
https://www.javacodegeeks.com/2017/11/difference-component-service-controller-repository-spring.html

Quest : Difference between @RestController and @Controller Annotation in Spring MVC and REST ?
Ans   : @RestController annotation in Spring MVC is a combination of @Controller and @ResponseBody annotation. It was added into Spring 4.0 to make the development of RESTful Web Services in Spring framework easier.
		The @Controller is a specialization of @Component annotation while @RestController is a specialization of @Controller annotation. Actually is annotated with @Controller and @ResponseBody as shown below
     @Controller
     @ResponseBody
     public @interface RestController		

Quest : Differences between @RequestParam and @PathVariable annotations in Spring MVC?
Ans   : Both @RequestParam and @ParthVariable are used to extract values from the HTTP request.
        As the name suggests @RequestParam is used to get the request parameters from URL, also known as query parameters, while @PathVariable extracts values from URI.
		
Example : http://localhost:8080/shop/order/1001/receipts?date=12-05-2017, then you can use the @RequestParam annotation to retrieve the query parameter
         date and you can use @PathVariable to extract the orderId i.e. “1001” as shown below		
		
Controller Class :
@RequestMapping(value="/order/{orderId}/receipts", method = RequestMethod.GET)

public List listUsersInvoices(
@PathVariable("orderId") int order,

@RequestParam(value = "date", required = false) Date dateOrNull) {

...

}


Quest : Use of GET, POST , PUT , DELETE ,PATCH , HEAD , OPTIONS in Rest APIs ?
https://assertible.com/blog/7-http-methods-every-web-developer-should-know-and-how-to-test-them#head

Ans   : GET : The HTTP GET method is used to **read** (or retrieve) a representation of a resource. In the “happy” (or non-error) path, GET returns a representation in XML or JSON and an HTTP response code of 200 (OK). In an error case, it most often returns a 404 (NOT FOUND) or 400 (BAD REQUEST). 
        Example : GET http://www.example.com/customers/12345 or GET http://www.example.com/customers/12345/orders  or GET http://www.example.com/buckets/sample

		POST : The POST verb is most-often utilized to **create** new resources. On successful creation, return HTTP status 201, returning a Location header with a link to the newly-created resource with the 201 HTTP status.
		       POST is neither safe nor idempotent. It is therefore recommended for non-idempotent resource requests. Making two identical POST requests will most-likely result in two resources containing the same information.
		Example : POST http://www.example.com/customers  or POST http://www.example.com/customers/12345/orders
		
		PUT : PUT is most-often utilized for **update** capabilities, PUT-ing to a known resource URI with the request body containing the newly-updated representation of the original resource.
		     If using PUT for create, return HTTP status 201 on successful creation. 
	    Example : PUT http://www.example.com/customers/12345  or PUT http://www.example.com/customers/12345/orders/98765  or PUT http://www.example.com/buckets/secret_stuff

        DELETE : DELETE is pretty easy to understand. It is used to **delete** a resource identified by a URI.On successful deletion, return HTTP status 200 (OK) along with a response body
        Example : DELETE http://www.example.com/customers/12345 or DELETE http://www.example.com/customers/12345/orders  or DELETE http://www.example.com/bucket/sample

        PATCH : PATCH method is the correct choice for partially updating an existing resource and PUT should only be used if you’re replacing a resource in its entirety.
               NOTE : PATCH method is not a replacement for the POST or PUT methods.It applies a delta (diff) rather than replacing the entire resource.
       
        HEAD : The HEAD method is almost identical to GET, except without the response body. In other words, if GET /users returns a list of users, then HEAD /users will make the same request but won't get back the list of users. 
               Making API requests with HEAD methods is actually an effective way of simply verifying that a resource is available. It is good practice to have a test for HEAD requests everywhere you have a test for GET requests (as long as the API supports it).
			   HEAD requests are useful for checking what a GET request will return before actually making a GET request -- like before downloading a large file or response body.
			   Retrieving metadata about the resource, e.g. its media type or its size, before making a possibly costly retrieval
		Response of HEAD : HTTP/1.1 200 OK
						   Accept-Ranges: bytes
						   Content-Type: text/html; charset=UTF-8
						   Date: Wed, 08 May 2013 10:12:29 GMT
						   ETag: "780602-4f6-4db31b2978ec0"
						   Last-Modified: Thu, 25 Apr 2013 16:13:23 GMT
						   Content-Length: 1270 
		
        OPTIONS : OPTIONS method returns info about API (methods/content type)
        Response of OPTIONS : HTTP/1.1 200 OK
							  Allow: GET,HEAD,POST,OPTIONS,TRACE
							  Content-Type: text/html; charset=UTF-8
							  Date: Wed, 08 May 2013 10:24:43 GMT
						      Content-Length: 0


Quest : What is Springboot? Difference between Springboot and Spring MVC ?
Ans   : While setting up the Spring project First of all, we would need to identify the frameworks we want to use, which versions of frameworks to use and how to connect them together. 
	    All web application have almost similar needs; like for Spring MVC --> Spring MVC, Jackson Databind (for data binding), Hibernate-Validator (for server side validation using Java Validation API) 
		and Log4j (for logging). When creating this course, we had to choose the compatible versions of all these frameworks.

      pom.xml
	  -------
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-web</artifactId>
    <version>5.1.0.RELEASE</version>
</dependency>	  
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-webmvc</artifactId>
	<version>4.2.2.RELEASE</version>
</dependency>
<dependency>
	<groupId>com.fasterxml.jackson.core</groupId>
	<artifactId>jackson-databind</artifactId>
	<version>2.5.3</version>
</dependency>
<dependency>
	<groupId>org.hibernate</groupId>
	<artifactId>hibernate-validator</artifactId>
	<version>5.0.2.Final</version>
</dependency>
<dependency>
	<groupId>log4j</groupId>
	<artifactId>log4j</artifactId>
	<version>1.2.17</version>
</dependency>

 
SpringBoot : Spring Boot is basically an extension of the Spring framework which eliminated the boilerplate configurations required for setting up a Spring application.
 
Let’s consider an example : If you want to develop a web application or an application to expose restful services, Spring Boot Starter Web is the 
                            starter to pick. Let's create a quick project with Spring Boot Starter Web using Spring Initializr. 
							and also SpringBoot comes with Embedded server to avoid complexity in application deployment. [by default port of Server is 8080 but if you want to change then go to your application.properties and write server.port = 8084]
						    so unlike Spring, Spring Boot requires only one dependency to get a web application up and running: 

	pom.xml
	-------
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

Dependencies can be classified into:
Spring: core, beans, context, aop
Web MVC: (Spring MVC)
Jackson: for JSON Binding
Validation: Hibernate Validator, Validation API
Embedded Servlet Container: Tomcat
Logging: logback, slf4j

Any typical web application would use all these dependencies. Spring Boot Starter Web comes pre-packaged with these. As a developer, I would not need to worry about either these dependencies or their compatible versions.

Spring Boot Starter Project Options :
spring-boot-starter-test: Unit testing and Integration Testing
spring-boot-starter-data-jpa: Spring Data JPA with Hibernate

Another good example is testing libraries. We usually use the set of Spring Test, JUnit, Hamcrest, and Mockito libraries. In a Spring project, we should add all these libraries as dependencies.
But in Spring Boot, we only need the starter dependency for testing to automatically include these libraries.


Quest : Where we configure DB details in SpringBoot ?
Ans : We configure our datasource and JPA settings in Application.properties.
     
Application.properties:
	 
	 #==== connect to mysql ======#
spring.jpa.hibernate.ddl-auto=update
spring.datasource.url=jdbc:mysql://localhost:3306/mysqltutorial?useSSL=false
spring.datasource.username=root
spring.datasource.password=
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5Dialect

Quest : How SpringBoot Application starts ?
Ans   : We need to provide starter in pom.xml and need write class with main(). as SpringBoot comes up with embaded Server which runs by default on 8080 (by default)

Main Class to start Application :

@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}


Quest : Difference between application.properties and application.yml ?
https://www.mkyong.com/spring-boot/spring-boot-profile-based-properties-and-yaml-example/
Ans   : SpringBoot supports both application.properties and application.yml files. We need to create multiple properties files based on different environment(dev,prod) details where we create different profile based on the environment
        but same can be done in single application.yml file instead having multiple files.
		
 Note : All application.properties or application.yml files should be under src/main/resources--->
	
Profile based Properties :
--------------------------

application.properties :
-----------------------
#Logging
logging.level.org.springframework.web=ERROR
logging.level.com.mkyong=ERROR
logging.level.=error

#spring
spring.main.banner-mode=off
spring.profiles.active=dev

application-dev.properties
--------------------------
#dev environment
server.email: dev@mkyong.com
server.cluster[0].ip=127.0.0.1
server.cluster[0].path=/dev1
server.cluster[1].ip=127.0.0.2
server.cluster[1].path=/dev2
server.cluster[2].ip=127.0.0.3
server.cluster[2].path=/dev3

application-prod.properties
---------------------------
#production environment
server.email: prod@mkyong.com
server.cluster[0].ip=192.168.0.1
server.cluster[0].path=/app1
server.cluster[1].ip=192.168.0.2
server.cluster[1].path=/app2
server.cluster[2].ip=192.168.0.3
server.cluster[2].path=/app3

Profile based YAML :  In YAML, we can create multiple profiles by using a “—” separator.
--------------------
application.yml :
-----------------
logging:
  level:
     : error
    org.springframework: ERROR
    com.mkyong: ERROR

spring:
  profiles:
    active: "dev"
  main:
    banner-mode: "off"

server:
  email: default@mkyong.com

---

spring:
  profiles: dev
server:
  email: dev@mkyong.com
  cluster:
    - ip: 127.0.0.1
      path: /dev1
    - ip: 127.0.0.2
      path: /dev2
    - ip: 127.0.0.3
      path: /dev3

---

spring:
  profiles: prod
server:
  email: prod@mkyong.com
  cluster:
    - ip: 192.168.0.1
      path: /app1
    - ip: 192.168.0.2
      path: /app2
    - ip: 192.168.0.3
      path: /app3


Quest : How to configure Hibernate with Spring ?
Ans   : http://www.javatpoint.com/hibernate-and-spring-integration
		http://websystique.com/springmvc/spring-4-mvc-and-hibernate4-integration-example-using-annotations/
		http://www.codejava.net/frameworks/spring/spring-4-and-hibernate-4-integration-tutorial-part-1-xml-configuration

Quest : How to use and types of joins in  hibernate ?
Ans   : HQL supports Joins (inner join, left outer join, right outer join and full join). 
Example ->  select e.name, a.city from Employee e INNER JOIN e.address a. In this query, Employee class should have a variable named address {case Sensitive}.

Quest : Isolation Level in JDBC?
Quest : What is the difference in Ant and Maven Tool ?


Infosys :
--------
Quest : What is Serialization ?
Quest : Which one is better Interface or Abstract Class in java if we have Single level Inheritance ?
Quest : What is Observer Design Pettern ?
Quest : How HasMap works Internally ?
Quest : Explain Hibernate First and Second level Caching ?
Quest : Difference between SQL and HQL ?
Quest : What is Normalization in DB ?
ANs : 


Congnizant:
----------
Quest : how get Prototype Bean instance everytime if it is injected to Singleton Bean ?
http://netjs.blogspot.in/2016/02/injecting-prototype-bean-in-singleton-spring.html
Ans   : 
1. lookup method injection : Lookup method injection is the ability of the container to override methods on container managed beans, to return the lookup 
------------------------     result for another named bean in the container. The Spring Framework implements this method injection by using bytecode generation
                             from the CGLIB library to generate dynamically a subclass that overrides the method.
 
XML Configuration will look like this:
--------------------------------------
<bean id="requestManager" class="org.netjs.prog.RequestManager">
       <lookup-method name="getRequestHandler" bean="requestHandler"/>
</bean>
  
<bean id="requestHandler" class="org.netjs.prog.RequestHandler" scope="prototype">

Note that the bean which is defined with the look up method will be dynamically subclassed by the Spring framework (using CGLIB library) and this subclass will override and provide implementation for the methods which are configured as look-up method.
The dynamically generated proxy will delegate all the non-lookup methods to the original class. For the lookup methods it will use the implementation it has provided.

Quest : Difference between Optimistic Locking & Pessimistic Locking in Database ? 
Ans   : 
Pessimistic locking :
--------------------
On updating the data, the record gets locked and no one else can access that record for updating. It becomes a read-only record till the lock is released. Once the lock gets released, the record can be locked again and get updated for a different user.

An example about pessimistic locking based on well known hr schema, suppose user1 and user2 are two different users (two distinct transactions) using pessimistic locking, both of them try to change the same row of data as follows:

    User1 calls EmployeesImpl.setSalary(1000) on a particular row, so user1 immediately acquire a lock on that row.
    Now user2 calls EmployeesImpl.setSalary(2000) on the same row, user2 tries to acquire a lock on the row and receives oracle.jbo.AlreadyLockedException.


Optimistic locking :
-------------------
This allows multiple user to open up the same record for updation . Record gets locked only while updating the record. This is the most preferred way of locking for the web application.

An example about optimistic locking, suppose user1 and user2 are two different users (two distinct transactions) using optimistic locking, both of them try to change the same row of data as follows:

    User1 calls EmployeesImpl.setSalary(1000) on a particular row, user1 does not immediately acquire a lock on that row.
    User2 calls EmployeesImpl.setSalary(2000) on  the same row. User1 and User2 now have different entity cache for the same row.
    User2 calls commit() action, as part of the commit cycle the changed row is posted to the database. before the update can be executed, user2 acquires a lock on that row. The lock expires immediately, when the commit command is sent to the database.
    User1 now calls commit() action, BC4J tries to post the changed row to the database, right before posting it, it attempts to acquire a lock on that row. BC4J recognizes that the row has been changed by another user and that updating the row would overwrite another transaction’s changes, so it throws an oracle.jbo.RowInconsistentException.

Note : Finally, Whatever you use, you can lock a row at any time by calling EntityImpl.lock() on the corresponding entity object instance, even if the locking mode is optimistic. 
----   



Hibernate lock mode: 
--------------------

Quest : Difference b/w ANT and Maven ?
Ans   : Maven came after ANT and offers much more than a build tool. Main difference between ANT and Maven is that In ANT you need to define every thing i.e. source directory, build directory, target directory etc while Maven adopts principle of Convention over configuration. Which means Maven has predefined project structure i.e. standard directory for source files, test files and resources
Maven solves many of these problem by introducing standard convention and better dependency management.

1. One major difference between Maven and ANT is that Maven requires less configuration than ANT because it works on principle of Convention over configuration and assumes reasonable default e.g. java source file in ${basedir}/src/main/java, resources on ${basedir}/src/main/resources, JUnit test cases on ${basedir}/src/test/java etc. It also creates Java class files on ${basedir}/target/classes and JAR file on ${basedir}/target directory. On the other hand ANT requires all these directories supplied as configuration, usually in ANT build file e.g. build.xml.

2) Another significant difference between Maven and ANT is dependency Management. Maven introduced concept of repository, which is a central place to store all libraries, JARs etc. Maven allows you to use central maven repository as well as local repository and automatically download dependency during build process. While ANT based project generally use ${lib} as directory to store dependencies. Changing and updating dependency is much easier in maven than ANT because you don't need to manually download dependency. Having an organization wide central repository also helps to remove redundancy across different projects.

3) Third and most important difference between Maven and ANT is that, Maven offers a consistent and common interface to build Java projects. All you need to do is download the project and run mvn install to build it. Also by knowing maven conventions and looking at pom.xml, one can easily understand where source files are and what are project dependencies.

4) Another technical difference between ANT and Maven is that ANT task doesn't have any lifecycle, you need to define targets and there dependencies. While Maven has lifecycle, which is invoked when you run commands like mvn install. Maven executes a series of steps as a result of this command to produce artifacts e.g. JAR file, which is end of life cycle.


5) Maven also enforce a standard naming convention for artifacts defined using groupId, artifactId and version. Also one more difference between ANT and Maven is that, Maven is more than just a build tool, it act as project management tool and can generate reports etc,

POM ==> Project Object Model


 build.xml file :
 ---------------
  <?xml version="1.0"?>
<project name="test" default="all" basedir=".">
  <property name="src"   value="src"/>
  <property name="build" value="build"/>
  <property name="lib"   value="lib"/>

<target name="all" depends="clean, compile" description="Builds the whole project">
    <echo>Doing all</echo>
  </target>

<target name="Clean" description="Removes previous build">
    <delete verbose="true">
      <fileset dir="${build}"/>
    </delete>
  </target>

<target name="compile" depends="clean" description="compile whole project">
    <echo>compile ${ant.project.name} </echo>
    <copy file="${src}/splashscreen.jpeg" tofile="${build}/splashscreen.jpeg"/>
    <javac srcdir="${src}" destdir="${build}" includes="Test.java"/>
  </target>
</project>



Quest :Do we need to mark transactions as read-only for read-only Object which is not going to be modified ever ?
http://stackoverflow.com/questions/26327274/do-you-need-a-database-transaction-for-reading-data
Ans : 1. All database statements are executed within the context of a physical transaction, even when we don’t explicitly declare transaction boundaries (BEGIN/COMMIT/ROLLBACK).

2. If you don't declare transaction boundaries, then each statement will have to be executed in a separate transaction (autocommit mode). This may even lead to opening and closing one connection per statement unless your environment can deal with connection-per-thread binding.

3. Declaring a service as @Transactional will give you one connection for the whole transaction duration, and all statements will use that single isolation connection. This is way better than not using explicit transactions in the first place. 

4. Transactions for reading might look indeed strange and often people don't mark methods for transactions in this case. But JDBC will create transaction anyway, it's just it will be working in autocommit=true if different option wasn't set explicitly.

5. But there is no guarantee that your method doesn't write into the database. If you mark method as @Transactional(readonly=true), Spring will set the JDBC transaction into a read-only mode, thus you'll dictate whether it's actually possible to write into DB in scope of this transaction.

6 . Accoring to my experience with JPA implementation in J2EE, a Transaction manager is always needed in order to perform CRUD operation safety, by guaranteeing a rollback in order to preserve data integrity.

7. I have seen faulty programs to kill huge database systems, because they just read data, but never commit, forcing the transaction log to grow, because the DB can't release the transaction data before a COMMIT or ROLLBACK, even if the client did nothing for hours.



Quest : How Object takes Memory and How String takes Memory ?
Quest : How Array returns value when we pass index to array ?

---------------------------------------------------------
Quest : What are JAR ,WAR and EAR ?
1. Java Archives (JAR)—A JAR file encapsulates one or more Java classes, a manifest, and a descriptor. JAR files are the lowest level of archive. JAR files are used in J2EE for packaging EJBs and client-side Java Applications.

2. Web Archives (WAR)—WAR files are similar to JAR files, they contains Servlets, JSPs, htmls , css, xmls and supporting classes.

3. Enterprise Archives (EAR)—
-------------






 
